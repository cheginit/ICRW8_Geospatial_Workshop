---
title: "Introduction"
format: 
  html:
    toc: true
    toc-depth: 4
    toc-location: left
    self-contained: true
    code-link: true
    code-fold: true
editor: visual
date: 2023-06-05

---

## Introduction

Housekeeping, introductions

## Key Concepts Across Both languages

In both R and Python:

### proj, gdal
- Spatial data structures across languages and applications is primarily organized through [OSgeo](https://www.osgeo.org) and [OGC](https://www.ogc.org)) _and_ a few core libraries underpin spatial libraries in programming languages and in software applications(R, Python, QGIS, ArcPro)!

These libraries include: 

  - **PROJ** --> projections, transformations  
  
  - **GEOS** --> Geometry operations (measures, relations)
  
  - **GDAL** --> geodata abstraction and processing (read, write)

### netcdf

### requesting web services (APIs)
More and more data is available as web services, and the data is stored in a remote server in JSON, XML, HTML format which is accessible through API’s.

**JSON** (JavaScript Object Notation) is a lightweight data-interchange format which is easy for machines to generate and parse; easy for humans to write and read.

Sample JSON format :
{ “data”: “Click Here”, “size”: 36, “style”: “bold”, “name”: “text1”, }

**API** - An Application Programming Interface (API) takes a structured request from an application and returns structured results from the host application. With a **Rest API** you're getting a representation of the requested data stored in a server. A **Rest API** also is what we call 'stateless', which means a server doesn't store any data between requests from clients.

**Rest APIs** access data through **uniform resource identifiers (URIs)**, which are essentially a string of characters that identify a specific resource. The type of URI used by a **Rest API** is a **uniform resource locator (URL)**.

**HTTP** clients are used for accessing the API. **HyperText Transfer Protocol (HTTP)** enables communication between the client and server using **HTTP** methods. If we want to access or manipulate resources a **Rest API** uses specific request verbs we need to become familiar with:

- GET: used to acquire data from a database

- POST: used to add data to a database

- PUT: update the data in a database

- DELETE: delete data in a database


### drainage basins and catchments - mainstems and flowpaths

### Geospatial data representation fundamentals, simple features and geospatial grids
- "Vector" data are comprised of points, lines, and polygons that represent discrete spatial entities, such as a river, watershed, or stream gauge.

- "Raster" data divides spaces into rectilinear cells (pixels) to represent spatially continuous phenomena, such as elevation or the weather. The cell size (or resolution) defines the fidelity of the data.

```{r, fig.align='center', echo = FALSE, out.width="75%" }
knitr::include_graphics("img/09-vec-raster.jpg")
```

Simple Features (officially Simple Feature Access) is both an OGC and International Organization for Standardization (ISO) standard that specifies how (mostly) two-dimensional geometries can represent and describe objects in the real world. Simple features includes:

* a class hierarchy
* a set of operations
* binary and text encodings

It describes how such objects can be stored in and retrieved from databases, and which geometrical operations should be defined for them.

It outlines how the spatial elements of POINTS (XY locations with a specific coordinate reference system) extend to LINES, POLYGONS and GEOMETRYCOLLECTION(s).

The “simple” adjective also refers to the fact that the line or polygon geometries are represented by sequences of points connected with straight lines that do not self-intersect.

```{r, fig.align='center', echo = FALSE, out.width="75%" }
knitr::include_graphics("img/09-sf-model.png")
```

## Demonstration of Key Concepts in Each Language

-   drainage basins and catchments - mainstems and flowpaths
-   geospatial data representation fundamentals, simple features and geospatial grids

### Examples in R
#### sf: simple features
In R, the [`sf` package](https://cran.r-project.org/web/packages/sf/index.html) provides "_support for simple features, a standardized way to encode spatial vector data.... [and] Binds to 'GDAL' for reading and writing data, to 'GEOS' for geometrical operations, and to 'PROJ' for projection conversions and datum transformations._" 

When using R, you' are're using an interface to the core community standards, software, and practices (this isn't exclusive to R). TO highlight this we can install (do this once) and attach `sf` to view the external dependencies versions of the libraries linked to `sf`. 

```{r}
#| message: false
# install.packages("sf")
library(sf)

sf_extSoftVersion()
```

The bindings to these lower-level C libraries, and, the larger `sf` ecosystem in R can be seen below:

```{r, fig.align='center', echo = FALSE, out.width="75%" }
knitr::include_graphics("img/09-sf-depends.png")
```

In the `sf` implementation in the R ecosystem stores simple feature geometries (sfg) as part of a larger data.frame using a simple feature geometry list-column (sfg). The collection of attribute and spatial information define a simple feature that can be operated on in both table (SQL) and spatial (GEOS, etc) contexts. Not only does this allow us to make the most use of the growing spatial community but _also_ of the growing data science community (see `ggplot`, `dplyr`, `data.table`, `dbplyr`, `arrow`, etc.)

In practice, an `sf` object in R looks like the following:

```{r, fig.align='center', echo = FALSE, out.width="75%" }
knitr::include_graphics("img/sf_xfig.png")
```


We can break this down following examples presented in the recently published [Spatial Data Science](https://r-spatial.org/book/03-Geometries.html) by Edzar Pebesma and Rober Bivand. The most common simple feature geometries used to represent a _single_ feature are:

| type                      | description                                                               |
|---------------------------|---------------------------------------------------------------------------|
| `POINT`                   | single point geometry |
| `MULTIPOINT`              | set of points |
| `LINESTRING`              | single linestring (two or more points connected by straight lines) |
| `MULTILINESTRING`         | set of linestrings |
| `POLYGON`                 | exterior ring with zero or more inner rings, denoting holes |
| `MULTIPOLYGON`            | set of polygons |
| `GEOMETRYCOLLECTION`      | set of the geometries above  |



```{r}
library(sf) |> suppressPackageStartupMessages()
par(mfrow = c(2,4))
par(mar = c(1,1,1.2,1))

# 1
p <- st_point(0:1)
plot(p, pch = 16)
title("point")
box(col = 'grey')

# 2
mp <- st_multipoint(rbind(c(1,1), c(2, 2), c(4, 1), c(2, 3), c(1,4)))
plot(mp, pch = 16)
title("multipoint")
box(col = 'grey')

# 3
ls <- st_linestring(rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)))
plot(ls, lwd = 2)
title("linestring")
box(col = 'grey')

# 4
mls <- st_multilinestring(list(
  rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)),
  rbind(c(3,0), c(4,1), c(2,1))))
plot(mls, lwd = 2)
title("multilinestring")
box(col = 'grey')

# 5 polygon
po <- st_polygon(list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
    rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))))
plot(po, border = 'black', col = '#ff8888', lwd = 2)
title("polygon")
box(col = 'grey')

# 6 multipolygon
mpo <- st_multipolygon(list(
    list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
        rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))),
    list(rbind(c(3,7), c(4,7), c(5,8), c(3,9), c(2,8), c(3,7)))))
plot(mpo, border = 'black', col = '#ff8888', lwd = 2)
title("multipolygon")
box(col = 'grey')

# 7 geometrycollection
gc <- st_geometrycollection(list(po, ls + c(0,5), st_point(c(2,5)), st_point(c(5,4))))
plot(gc, border = 'black', col = '#ff6666', pch = 16, lwd = 2)
title("geometrycollection")
box(col = 'grey')
```

```{r}
p
mp
ls
mls
po
mpo
gc
```


This extends the idea of ["tidy" data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) in that each row represents one observation, which has one geometric representation of the real world feature it describes.

An example of basic use:
```{r}
# Define file path
(filename <- system.file("shape/nc.shp", package="sf"))

# read in file
(nc <- read_sf(filename) )
```

```{r}
# Map
plot(nc['SID79'])

# Spatial measures!
head(st_area(nc))

# Spatial operations!
{
  st_union(nc) |> plot()
  
  st_centroid(nc)$geometry |> plot(col = "red", add = TRUE)
}

# data science operations
library(dplyr)

{
 plot(nc$geometry)
 plot(slice_max(nc, AREA, n = 10)$geometry, 
      col = "red", add = TRUE)
 plot(slice_max(nc, AREA, n =5)$geometry, 
      col = "yellow", add = TRUE)
 plot(slice_max(nc, AREA, n = 1)$geometry, 
      col = "green", add = TRUE)
}

```

#### terra and stars 
For accessing raster data - first look at terra:
```{r}
# install.packages(terra)
library(terra)

gdal()
```

```{r}
DT::datatable(gdal(drivers = TRUE))
```

#### httr and jsonlite
In R, httr and jsonlite packages are used to consume the API’s that provide data in json format.

**httr**
httr provides us with an HTTP client to access the API with GET/POST methods, passing query parameters, and verifying the response with regard to the data format.

**jsonlite**
This R package is used to convert the received json format to readable R object or data frame. `jsonlite` can also be used to convert R objects or a data frame to a json format data type.

Along with these two packages, `rlist` in R can be used to perform additional manipulation on the received json response. `list.stack` and `list.select` are two important methods exposed by `rlist` that can be used to get parsed json data into a `tibble`.

To learn about these (and other) packages, type `?httr`, `?jsonlite` and `?rlist` in the console of Rstudio to view the documentation.

Here we see an example using a JSON API from the world bank that uses a GET request below - we can see a couple ways of passing request parameters - first we'll embed the query directly in the URL for the request itself:
```{r}
#| message: false
#| warning: false
library(httr) 
library(jsonlite) 
library(rlist) 
library(dplyr)
library(data.table)

jsonResponse <- httr::GET("http://api.worldbank.org/country?per_page=10&region=OED&lendingtype=LNX&format=json")
```

We can also generate the query by passing it in a separate list we create and adding as a query parameter in the GET request
```{r}
query<-list(per_page="10",region="OED",lendingtype="LNX",format="json")
jsonResponse <- httr::GET("http://api.worldbank.org/country",query=query)
```

The `jsonlite` package can be used to parse our response which we indicated above to return as json.  Why does the attempt below return an error?
```{r}
#| eval: false
#| warning: false
df <- jsonlite::fromJSON(jsonResponse)
```

HINT: what type of object is `jsonResponse` above?

```{r}
typeof(jsonResponse)
```
We can also get information about the response using `httr`:
```{r}
http_type(jsonResponse)
```
We have a list - let's take a look to figure out to pull out what we want into a data frame:
```{r}
names(jsonResponse)
```

It seems like `content` is what we want, how do we pull out?
```{r}
#| eval: false
#| warning: false
df <- jsonlite::fromJSON(jsonResponse$content)
```

Still doesn't work - we need to do some further parsing of this response using `content` in `httr` which we can then pass to `jsonlite` and the `fromJSON` function to get data into a data frame
```{r}
jsonResponseParsed <- httr::content(jsonResponse, as="parsed")
is.list(jsonResponseParsed)
names(jsonResponseParsed[[1]])
names(jsonResponseParsed[[2]])
#Hmmm
is.list(jsonResponseParsed[[2]][[1]]) 
names(jsonResponseParsed[[2]][[1]])
# now we're getting somewhere...
names(jsonResponseParsed[[2]][[2]])
```
We convert the parsed json response list to data table using `lapply` and `rbindlist`:
```{r}
df <- lapply(jsonResponseParsed[[2]],as.data.table) 
typeof(df) # still a list - one more step
dt <- rbindlist(df, fill = TRUE)
```

Some APIs like [GitHub]("https://api.github.com") are easier to pull directly into a dataframe using `fromJSON`
```{r}
myGitHubRepos <- fromJSON("https://api.github.com/users/mhweber/repos")

# It returns 79 variables about my repos - we can use select to just get the ones we want to see
myGitHubRepos <- myGitHubRepos |> 
  dplyr::select(name, stargazers_count, watchers_count, language, has_issues, forks_count)
head(myGitHubRepos)
```

### Examples in Python (will be in a separate notebook in binder)

## Use Cases

### First show how satisfied?

-   hydro addressing and network navigation
-   catchment characteristics and accumulation
-   spatial data aggregation and resampling

### First use case walk-through

In R here and in separate notebook for Python

### Second use case walk-through

In R here and in separate notebook for Python

etc

## Data access summary -- web services and scalability


## Resources
### R
#### Spatial Data
[Spatial Data Science by Edzar Pebesma and Roger Bivand](https://r-spatial.org/book/)

[Geocomputation with R](https://r.geocompx.org/)

#### Web Services
[Accessing REST API (JSON data) using httr and jsonlite](https://rstudio-pubs-static.s3.amazonaws.com/480665_ba2655419209496dbb799f1c7d050673.html
)
### Python
[GeoPandas](https://geopandas.org/en/stable/index.html)

[Python Foundation for Spatial Analysis](https://courses.spatialthoughts.com/python-foundation.html)

[Python for Geographic Data Analysis](https://pythongis.org/index.html)

  